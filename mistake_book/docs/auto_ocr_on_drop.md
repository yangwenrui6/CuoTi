# 拖拽图片自动OCR识别

## 修改日期
2026-02-03

## 功能描述
实现拖拽图片后自动触发OCR识别,识别结果直接填充到题目内容,无需手动点击识别按钮,大幅提升用户体验和录入效率。

## 用户体验改进

### 修改前
1. 拖拽图片到上传区域
2. 图片加载完成
3. 点击"🔍 OCR识别"按钮
4. 等待识别完成
5. 识别结果填充到题目内容

**问题:**
- 需要额外点击操作
- 流程不够流畅
- 用户可能忘记点击识别按钮

### 修改后
1. 拖拽图片到上传区域
2. 自动开始识别(显示"🔄 正在识别文字...")
3. 识别结果自动填充到题目内容
4. 自动聚焦到题目内容,方便编辑
5. 如需重新识别,点击"🔄 重新识别"按钮

**优势:**
- 零额外操作,拖拽即识别
- 流程更流畅自然
- 自动聚焦,方便后续编辑

## 技术实现

### 1. 自动触发机制

**on_image_dropped() 方法:**
```python
def on_image_dropped(self, path: str):
    """图片拖拽事件 - 自动触发OCR识别"""
    self.image_path = path
    self.ocr_btn.setEnabled(True)
    
    # 自动触发OCR识别
    self.auto_run_ocr()
```

### 2. 异步识别

**使用QTimer避免阻塞UI:**
```python
def auto_run_ocr(self):
    """自动运行OCR识别"""
    # 更新UI状态
    self.drop_zone.label.setText("🔄 正在识别文字...")
    
    # 延迟100ms执行,避免阻塞UI
    from PyQt6.QtCore import QTimer
    QTimer.singleShot(100, self._do_ocr_recognition)
```

### 3. 智能状态提示

**识别过程中的状态变化:**

| 阶段 | 拖拽区域提示 | OCR按钮状态 |
|------|------------|------------|
| 初始状态 | "📸 拖拽图片到此处" | 禁用 |
| 图片加载 | "✅ 图片已加载" | 启用 |
| 识别中 | "🔄 正在识别文字..." | "识别中..." (禁用) |
| 识别成功 | "✅ 识别成功 (X 行)" | "✅ 识别完成" (启用) |
| 识别失败 | "❌ 识别失败,可手动输入" | "🔄 重新识别" (启用) |
| OCR不可用 | "⚠️ OCR功能未启用" | 禁用 |

### 4. 自动聚焦

**识别成功后自动聚焦到题目内容:**
```python
if success and recognized_text:
    # 自动填充
    self.content_edit.setPlainText(recognized_text)
    
    # 自动聚焦,方便用户编辑
    self.content_edit.setFocus()
```

### 5. 错误处理

**OCR引擎不可用:**
- 检查 `ocr_engine` 是否存在
- 检查 `is_available()` 是否返回True
- 显示友好提示,不弹窗打扰

**识别失败:**
- 不强制弹窗(避免打断用户)
- 在拖拽区域显示失败提示
- 允许用户手动输入或重新识别

## 用户交互流程

### 场景1: 正常识别流程
```
用户拖拽图片
    ↓
图片预览显示
    ↓
自动开始识别 (显示"正在识别...")
    ↓
识别成功 (显示"识别成功 X行")
    ↓
内容自动填充到题目内容框
    ↓
光标自动定位到题目内容框
    ↓
用户可以直接编辑内容
```

### 场景2: 识别失败流程
```
用户拖拽图片
    ↓
图片预览显示
    ↓
自动开始识别
    ↓
识别失败 (显示"识别失败,可手动输入")
    ↓
用户选择:
  - 手动输入题目内容
  - 点击"重新识别"按钮重试
```

### 场景3: OCR不可用
```
用户拖拽图片
    ↓
图片预览显示
    ↓
检测到OCR不可用
    ↓
显示"OCR功能未启用"提示
    ↓
用户手动输入题目内容
```

## 按钮功能变化

### 修改前
- 按钮文字: "🔍 OCR识别"
- 功能: 首次识别
- 状态: 拖拽图片后启用

### 修改后
- 按钮文字: "🔄 重新识别"
- 功能: 重新识别(用于识别失败或结果不满意时)
- 状态: 拖拽图片后启用
- 提示: "拖拽图片后会自动识别,点击此按钮可重新识别"

## 性能优化

### 1. 异步执行
使用 `QTimer.singleShot(100, ...)` 延迟执行识别:
- 避免阻塞UI线程
- 给UI时间更新状态
- 提升用户体验

### 2. 状态检查
在识别前检查OCR引擎状态:
- 避免无效的识别尝试
- 减少错误和异常
- 提供友好提示

### 3. 智能提示
不同状态显示不同提示:
- 用户清楚当前进度
- 减少焦虑等待
- 明确下一步操作

## 代码结构

### 新增方法

**auto_run_ocr():**
- 自动触发OCR识别
- 检查OCR引擎状态
- 更新UI提示
- 使用QTimer异步执行

**_do_ocr_recognition():**
- 执行实际的OCR识别
- 处理识别结果
- 更新UI状态
- 自动聚焦到内容框

### 修改方法

**on_image_dropped():**
- 原功能: 保存图片路径,启用按钮
- 新增: 调用 `auto_run_ocr()` 自动识别

**run_ocr():**
- 原功能: 手动触发识别
- 保持不变,用于重新识别

## 用户反馈

### 视觉反馈
1. **拖拽区域文字变化**
   - 实时显示当前状态
   - 使用emoji增强可读性

2. **按钮状态变化**
   - 识别中禁用按钮
   - 完成后恢复可用

3. **自动聚焦**
   - 识别成功后光标定位
   - 提示用户可以编辑

### 错误反馈
1. **不强制弹窗**
   - 避免打断用户流程
   - 在界面上显示提示

2. **提供解决方案**
   - "可手动输入"
   - "重新识别"按钮

## 兼容性

### 向后兼容
- 保留"重新识别"按钮
- 用户仍可手动触发识别
- 不影响现有功能

### OCR不可用时
- 程序正常运行
- 显示友好提示
- 允许手动输入

## 测试建议

### 功能测试
1. 拖拽清晰图片 → 自动识别成功
2. 拖拽模糊图片 → 识别失败,显示提示
3. 无OCR依赖 → 显示"OCR功能未启用"
4. 点击"重新识别" → 重新执行识别

### 性能测试
1. 拖拽后UI是否流畅
2. 识别过程中能否操作其他控件
3. 识别时间是否合理(<3秒)

### 用户体验测试
1. 状态提示是否清晰
2. 自动聚焦是否方便
3. 错误提示是否友好

## 相关文件
- `src/mistake_book/ui/dialogs/add_dialog.py`

## 相关文档
- `docs/ocr_implementation.md` - OCR功能实现
- `docs/prevent_duplicate_save.md` - 防止重复保存

## 总结

通过自动触发OCR识别,实现了:
- **零操作**: 拖拽即识别,无需点击
- **流畅体验**: 异步执行,不阻塞UI
- **智能提示**: 实时反馈当前状态
- **容错处理**: 识别失败可重试或手动输入

这个改进大幅提升了错题录入的效率和用户体验,让OCR功能真正做到"无感使用"。
